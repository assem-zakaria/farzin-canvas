<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Image to SVG Path Editor</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas, svg { display: block; margin: 10px 0; border: 1px solid #ccc; }
    .controls { margin: 10px 0; }
    .controls > * { margin-right: 10px; }
    svg path:hover { stroke: red; stroke-width: 1; cursor: pointer; }
    #svgOutput { width: 600px; height: 600px; }

    #progressBarContainer {
      display: none;
      margin: 10px 0;
      width: 100%;
      max-width: 600px;
      height: 20px;
      background-color: #eee;
      border-radius: 10px;
      overflow: hidden;
    }

    #progressBar {
      width: 0%;
      height: 100%;
      background-color: #4caf50;
      transition: width 0.2s ease;
    }

    .texture-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
  </style>
</head>
<body>
  <h1>Upload and Trace Black & White Image</h1>

  <div class="controls">
    <input type="file" id="imageUpload" accept="image/png, image/jpeg" />
    <button id="traceButton">Trace Image</button>
    <button id="downloadButton">Download PNG (1000px)</button>
    <input type="color" id="colorPicker" value="#ff0000" />
    <input type="file" id="textureUpload" accept="image/*" />
    <div class="texture-controls">
      <label for="textureScale">Texture Scale:</label>
      <input type="range" id="textureScale" min="10" max="1500" value="100">
    </div>
  </div>

  <div id="progressBarContainer">
    <div id="progressBar"></div>
  </div>

  <canvas id="imageCanvas" style="display:none;"></canvas>
  <svg id="svgOutput"></svg>

  <script src="https://cdn.jsdelivr.net/gh/jankovicsandras/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>
  <script>
    const imageUpload = document.getElementById('imageUpload');
    const traceButton = document.getElementById('traceButton');
    const downloadButton = document.getElementById('downloadButton');
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const svgOutput = document.getElementById('svgOutput');
    const colorPicker = document.getElementById('colorPicker');
    const textureUpload = document.getElementById('textureUpload');
    const textureScaleSlider = document.getElementById('textureScale');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');

    let currentImage = null;
    let texturePattern = null;
    let textureScale = parseInt(textureScaleSlider.value);

    imageUpload.addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            currentImage = img;
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      }
    });

    traceButton.addEventListener('click', () => {
      if (!currentImage) return;

      // Show progress bar
      progressBarContainer.style.display = 'block';
      progressBar.style.width = '10%';

      setTimeout(() => {
        const tracedSVG = ImageTracer.imagedataToSVG(
          ctx.getImageData(0, 0, canvas.width, canvas.height),
          {
            corsenabled: true,
            scale: 1,
            pathomit: 1,
            colorsampling: 0,
            numberofcolors: 2,
            colorquantcycles: 3,
            blurradius: 0,
            blurdelta: 20
          }
        );

        progressBar.style.width = '60%';

        const parser = new DOMParser();
        const doc = parser.parseFromString(tracedSVG, "image/svg+xml");
        const paths = doc.querySelectorAll('path');

        svgOutput.innerHTML = '';

        const svgWidth = canvas.width;
        const svgHeight = canvas.height;
        svgOutput.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
        svgOutput.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        paths.forEach((p) => {
          p.setAttribute('fill', '#ffffff');
          p.setAttribute('stroke', '#000000');
          svgOutput.appendChild(p);
        });

        progressBar.style.width = '100%';

        setTimeout(() => {
          progressBarContainer.style.display = 'none';
          progressBar.style.width = '0%';
        }, 500);
      }, 100); // Short delay to allow progress bar to appear
    });

    svgOutput.addEventListener('click', e => {
      if (e.target.tagName === 'path') {
        if (texturePattern) {
          const id = `pattern-${Math.random().toString(36).substr(2, 5)}`;
          const defs = svgOutput.querySelector('defs') || svgOutput.insertBefore(
            document.createElementNS('http://www.w3.org/2000/svg', 'defs'),
            svgOutput.firstChild
          );

          const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
          pattern.setAttribute('id', id);
          pattern.setAttribute('patternUnits', 'userSpaceOnUse');
          pattern.setAttribute('width', textureScale);
          pattern.setAttribute('height', textureScale);

          const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
          img.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', texturePattern);
          img.setAttribute('width', textureScale);
          img.setAttribute('height', textureScale);
          pattern.appendChild(img);
          defs.appendChild(pattern);

          e.target.setAttribute('fill', `url(#${id})`);
        } else {
          e.target.setAttribute('fill', colorPicker.value);
        }
      }
    });

    textureUpload.addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          texturePattern = reader.result;
        };
        reader.readAsDataURL(file);
      }
    });

    textureScaleSlider.addEventListener('input', e => {
      textureScale = parseInt(e.target.value);
    });

    downloadButton.addEventListener('click', () => {
      const svgData = new XMLSerializer().serializeToString(svgOutput);
      const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.onload = () => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1000;
        tempCanvas.height = 1000 * img.height / img.width;
        const tctx = tempCanvas.getContext('2d');
        tctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

        const link = document.createElement('a');
        link.download = 'output.png';
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      };
      img.src = url;
    });
  </script>
</body>
</html>